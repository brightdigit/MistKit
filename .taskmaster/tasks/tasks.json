{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Refactor and Complete FieldValue System",
        "description": "Enhance the existing CKValue enum to match PRD's FieldValue specification with complete type-safe field handling, list types, and convenience accessors",
        "details": "Rename CKValue to FieldValue throughout the codebase and extend it with complete list type support for all primitive types (stringList, int64List, doubleList, dateList, locationList, referenceList, assetList). Add convenience accessors for all types (doubleValue, booleanValue, etc.). Ensure proper Codable implementation for CloudKit's millisecond timestamp format. Update the Asset struct to include init(fileURL:) for file uploads. Make all types conform to Sendable for Swift concurrency. Consider using Swift 6.0's new typed throws for better error handling.",
        "testStrategy": "Unit tests for all FieldValue cases including encoding/decoding, convenience accessors, list operations, and edge cases. Test proper millisecond timestamp conversion for dates. Verify Sendable conformance doesn't break existing functionality.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Rename CKValue to FieldValue Throughout Codebase",
            "description": "Perform a complete rename refactoring of CKValue enum to FieldValue across all files, updating all references, imports, and type annotations",
            "dependencies": [],
            "details": "Use Xcode's refactoring tools or search-and-replace to rename CKValue to FieldValue in RecordInfo.swift and any other files that reference it. Update all type annotations, function parameters, return types, and variable declarations. Ensure the rename is consistent in comments and documentation. Verify that all existing tests still compile and pass after the rename.",
            "status": "in-progress",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add List Type Support to FieldValue Enum",
            "description": "Extend FieldValue enum with new cases for all list types including stringList, int64List, doubleList, dateList, locationList, referenceList, and assetList",
            "dependencies": [
              "1.1"
            ],
            "details": "Add new enum cases for: stringList([String]), int64List([Int64]), doubleList([Double]), dateList([Date]), locationList([Location]), referenceList([Reference]), and assetList([Asset]). Ensure each list type properly handles empty arrays and nil values. Update the Codable implementation to correctly encode/decode these list types according to CloudKit's JSON format. Consider adding validation for maximum list sizes if CloudKit has such limitations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Convenience Accessors for All Field Types",
            "description": "Add computed properties to FieldValue for type-safe access to values like doubleValue, booleanValue, stringListValue, etc.",
            "dependencies": [
              "1.2"
            ],
            "details": "Create optional computed properties for each type: var stringValue: String?, var int64Value: Int64?, var doubleValue: Double?, var booleanValue: Bool?, var dateValue: Date?, var dataValue: Data?, var locationValue: Location?, var referenceValue: Reference?, var assetValue: Asset?, and corresponding list accessors. Each accessor should return nil if the enum case doesn't match the requested type. Consider adding throwing variants that throw an error for type mismatches. Add helper methods like isNull, isList, etc.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Update Asset Struct and Add File Upload Support",
            "description": "Enhance the Asset struct with init(fileURL:) initializer and ensure proper integration with FieldValue",
            "dependencies": [
              "1.3"
            ],
            "details": "Add init(fileURL: URL) initializer to Asset struct that reads file metadata and prepares it for upload. Include properties for fileSize, contentType detection from file extension, and local file reference. Ensure the Asset struct properly encodes to CloudKit's expected format with fileChecksum, size, referenceChecksum, wrappingKey, receipt, and downloadURL fields. Add validation for supported file types and size limits. Consider adding async methods for file upload preparation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add Sendable Conformance and Test Coverage",
            "description": "Make FieldValue, Asset, Location, Reference, and all related types conform to Sendable protocol and add comprehensive unit tests",
            "dependencies": [
              "1.4"
            ],
            "details": "Add Sendable conformance to FieldValue enum and all its associated types (Asset, Location, Reference). Ensure all stored properties are either immutable or thread-safe. Add @unchecked Sendable if needed with proper documentation. Write comprehensive unit tests covering: all FieldValue cases encoding/decoding, convenience accessors returning correct values, list operations, edge cases (empty lists, nil values), millisecond timestamp conversion for dates, Asset file URL initialization, and Sendable conformance verification. Test backward compatibility with existing code.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement CloudKitRecord Structure",
        "description": "Create the strongly-typed CloudKitRecord struct as the primary data model for all record operations",
        "details": "Replace the existing RecordInfo struct with CloudKitRecord that follows the PRD specification. Include recordName (optional for new records), recordType, recordChangeTag (optional), and fields dictionary using FieldValue. Add proper initializers with default values. Ensure Codable and Sendable conformance. Create bidirectional conversion methods between CloudKitRecord and the OpenAPI generated Components.Schemas.Record type. Consider property wrappers for field access patterns like @CloudKitField for type-safe field mapping in user models.",
        "testStrategy": "Test CloudKitRecord creation with all field types, serialization to/from JSON matching CloudKit format, conversion to/from OpenAPI types, and proper handling of optional fields. Verify record change tags are preserved during operations.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define CloudKitRecord struct with core properties",
            "description": "Create the CloudKitRecord struct with recordName, recordType, recordChangeTag, and fields dictionary using FieldValue enum",
            "dependencies": [],
            "details": "Define the CloudKitRecord struct with the following properties: recordName (String?, nil for new records), recordType (String, required), recordChangeTag (String?, for optimistic locking), and fields (Dictionary<String, FieldValue>). Ensure the struct conforms to Codable, Sendable, and Equatable protocols. Import the existing FieldValue enum from the codebase and ensure it properly represents all CloudKit field types (String, Number, Date, Asset, Location, Reference, List). Add computed properties for common operations like isNew (checks if recordName is nil).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement initializers and builder methods",
            "description": "Add comprehensive initializers with default values and convenience methods for creating CloudKitRecord instances",
            "dependencies": [
              "2.1"
            ],
            "details": "Create multiple initializers: init(recordType:) for new records with nil recordName, init(recordName:recordType:recordChangeTag:fields:) for full initialization, and init(recordType:fields:) for quick record creation. Add a builder pattern with methods like withField(_:value:) that return Self for chaining. Implement a convenience initializer that accepts a dictionary of field names to Any values and converts them to FieldValue types. Ensure all initializers properly handle optional parameters and provide sensible defaults (empty fields dictionary, nil change tag for new records).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create bidirectional conversion with OpenAPI Record type",
            "description": "Implement conversion methods between CloudKitRecord and Components.Schemas.Record from the OpenAPI generated code",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Implement init(from openAPIRecord: Components.Schemas.Record) that maps OpenAPI record fields to CloudKitRecord properties, handling the conversion of OpenAPI field value types to FieldValue enum cases. Create toOpenAPIRecord() -> Components.Schemas.Record method that converts CloudKitRecord back to the OpenAPI type for API calls. Handle edge cases like missing fields, null values, and ensure recordChangeTag is properly preserved during conversions. Map the OpenAPI's recordField dictionary to the strongly-typed FieldValue enum, including proper handling of complex types like assets, locations, and references. Leverage existing conversion logic from RecordInfo where applicable.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement @CloudKitField property wrapper",
            "description": "Create a property wrapper for type-safe field access and automatic field mapping in user-defined model types",
            "dependencies": [
              "2.1",
              "2.3"
            ],
            "details": "Design and implement @CloudKitField property wrapper that allows users to define model properties that automatically map to CloudKit fields. The wrapper should store the field key and handle conversion between Swift types and FieldValue. Support common types like String, Int, Double, Date, Data, CLLocation through the wrappedValue. Implement projectedValue to provide direct access to the underlying FieldValue. Add support for optional fields and default values. Create a CloudKitModel protocol that types can conform to, providing automatic encoding/decoding to CloudKitRecord through reflection of @CloudKitField properties. Include validation to ensure field names are valid CloudKit identifiers.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Build High-Level Service Protocol",
        "description": "Design and implement CloudKitServiceProtocol as the main abstraction layer interface with database-aware operations",
        "details": "Create CloudKitServiceProtocol with async methods for queryRecords, saveRecord, saveRecords (with atomic flag), deleteRecord, and lookupRecord. Each method should accept a Database enum parameter (public/private/shared). Implement proper return types using CloudKitRecord and QueryResult. Add pagination support through AsyncSequence for query results. Ensure all methods use async/await and proper error throwing. Consider using Result builders for query construction. Add support for desiredKeys parameter in lookup operations.",
        "testStrategy": "Create mock implementations of the protocol for testing. Test all CRUD operations across different databases. Verify atomic batch operations work correctly. Test pagination and AsyncSequence implementations. Ensure proper error propagation.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define CloudKitServiceProtocol with Core CRUD Methods",
            "description": "Create the main protocol interface with async methods for all database operations",
            "dependencies": [],
            "details": "Define CloudKitServiceProtocol with async methods: queryRecords, saveRecord, saveRecords, deleteRecord, and lookupRecord. Each method should accept a Database enum parameter (public/private/shared) and use proper async/await signatures with throws. Define associated types for Record and Query types. Include method signatures for both single and batch operations. Ensure all methods are designed to work with CloudKitRecord type from Task 2.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement QueryResult and Pagination Types",
            "description": "Create QueryResult type with pagination support and continuation tokens",
            "dependencies": [],
            "details": "Design QueryResult<T> generic type that wraps query results with records array, continuation token, and result metadata. Include properties for moreComing flag, syncToken for incremental changes, and desiredKeys that were requested. Implement ContinuationToken type for cursor-based pagination. Add support for result limits and offset handling. Ensure QueryResult conforms to Sendable for concurrent access.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create AsyncSequence Implementation for Paginated Results",
            "description": "Build AsyncSequence wrapper for automatic pagination of query results",
            "dependencies": [
              "3.2"
            ],
            "details": "Implement PaginatedQuerySequence conforming to AsyncSequence that automatically fetches subsequent pages using continuation tokens. Create AsyncIterator that manages state between page fetches and handles errors gracefully. Implement buffering strategy to optimize network calls. Add cancellation support through Task cancellation. Include options for page size and prefetching behavior. Ensure proper memory management for large result sets.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Database-Aware Operation Methods",
            "description": "Extend protocol with database-specific operation constraints and validation",
            "dependencies": [
              "3.1"
            ],
            "details": "Add database-aware method variants that enforce compile-time constraints (e.g., zones only in private database). Create DatabaseCapabilities enum defining what operations are valid for each database type. Implement method overloads that provide appropriate defaults based on database type. Add validation for shared database operations requiring proper record shares. Include helper methods for common database-specific patterns.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Atomic Batch Operations Support",
            "description": "Add support for atomic batch operations with transaction semantics",
            "dependencies": [
              "3.1",
              "3.4"
            ],
            "details": "Implement saveRecords method with atomic flag parameter for all-or-nothing batch saves. Create BatchOperation type that groups multiple operations (save, delete) into atomic units. Add support for operation dependencies within batches. Implement proper error handling that identifies which specific operations failed in non-atomic batches. Include rollback mechanisms for failed atomic operations. Add batch size limits and automatic chunking for large operations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add DesiredKeys and Query Optimization Support",
            "description": "Implement field-level fetching optimization with desiredKeys parameter",
            "dependencies": [
              "3.1",
              "3.2"
            ],
            "details": "Add desiredKeys parameter to lookup and query operations for selective field fetching. Implement FieldSelector type for type-safe field selection using KeyPaths or string-based selection. Create query builder with Result builders for intuitive query construction. Add caching layer that respects desiredKeys for partial record updates. Implement field merging strategies when combining partial fetches. Include validation to ensure required fields are always fetched.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Query Builder System",
        "description": "Create a type-safe, fluent query builder for constructing CloudKit queries with proper field type validation",
        "details": "Build RecordQuery struct with methods like where(), and(), or() that accept field names, operators (.equals, .greaterThan, .contains, etc.), and FieldValue parameters. Implement sorting with sorted(by:ascending:), limiting with limit(), and offset support. Add specialized support for location-based queries (distance from point). Use Swift's result builders (@resultBuilder) for declarative query syntax. Ensure queries validate field types at compile time where possible. Support for TRUEPREDICATE and full-text search tokens.",
        "testStrategy": "Test complex query construction with multiple conditions, all operator types, sorting, pagination. Verify type safety prevents invalid comparisons. Test location-based queries with distance calculations. Ensure query serialization matches CloudKit API format.",
        "priority": "high",
        "dependencies": [
          1,
          3
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create RecordQuery Structure with Basic Operations",
            "description": "Implement the foundational RecordQuery struct with basic where(), and(), or() methods that accept field names, operators, and FieldValue parameters",
            "dependencies": [],
            "details": "Create RecordQuery struct that conforms to Sendable. Implement basic query methods: where(field:operator:value:), and(field:operator:value:), or(field:operator:value:). Define QueryOperator enum with cases for .equals, .notEquals, .greaterThan, .greaterThanOrEqual, .lessThan, .lessThanOrEqual. Store query conditions internally as a tree structure to represent nested logical operations. Ensure the query can be serialized to CloudKit's filter format matching the OpenAPI specification.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement All CloudKit Query Operators",
            "description": "Add support for all CloudKit-specific operators including string operations, array operations, and special operators",
            "dependencies": [
              "4.1"
            ],
            "details": "Extend QueryOperator enum with CloudKit-specific operators: .contains, .beginsWith, .in, .notIn, .containsAll, .containsAny. Implement proper type checking to ensure operators are used with compatible field types (e.g., .contains only with strings/arrays). Add support for case-insensitive string comparisons. Implement null/nil checking operators. Ensure all operators properly serialize to CloudKit's expected format in the query filter.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add Sorting and Pagination Support",
            "description": "Implement sorting capabilities and pagination with limit and offset functionality",
            "dependencies": [
              "4.1"
            ],
            "details": "Add sorted(by:ascending:) method to RecordQuery that accepts field name and sort direction. Support multiple sort fields with order precedence. Implement limit() method to restrict result count. Add offset() method for pagination support. Create continuation token handling for efficient pagination across large result sets. Ensure sorting and pagination parameters are properly included in the query serialization.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Location-Based Query Support",
            "description": "Add specialized support for location-based queries with distance calculations from a point",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Create LocationQuery methods: near(field:location:radius:) for proximity searches. Implement distance calculation support using CLLocation coordinates. Add withinDistance(field:from:kilometers:) and withinDistance(field:from:miles:) convenience methods. Support bounding box queries with withinRegion(field:region:). Ensure location queries properly serialize to CloudKit's location filter format. Handle coordinate system conversions appropriately.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create @resultBuilder for Declarative Query Syntax",
            "description": "Implement a Swift result builder to enable declarative, SwiftUI-like query construction syntax",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Create @QueryBuilder result builder that allows declarative query syntax. Implement buildBlock() to combine multiple query conditions. Add buildEither() for conditional query building. Support buildOptional() for optional conditions. Create convenience functions like Where(), And(), Or(), SortBy() that work with the result builder. Enable syntax like: CloudKitQuery { Where(\"name\", .equals, \"John\"); And(\"age\", .greaterThan, 18); SortBy(\"createdAt\", ascending: false) }.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add TRUEPREDICATE and Full-Text Search Support",
            "description": "Implement support for TRUEPREDICATE queries and full-text search tokens",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Add .all() or .truePredicate() method to create queries that match all records. Implement full-text search support with .containsTokens(field:tokens:) method. Add token-based search operators for advanced text matching. Support CloudKit's tokenization options (word boundaries, stemming). Implement proper escaping for search tokens. Ensure TRUEPREDICATE and token searches serialize correctly to CloudKit's expected format.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Type-Safe Field Validation",
            "description": "Add compile-time field type validation to prevent invalid query operations",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4",
              "4.5",
              "4.6"
            ],
            "details": "Create phantom types or generic constraints to ensure field types match expected values at compile time. Implement FieldDescriptor protocol with associated type for field value type. Use Swift's type system to prevent invalid comparisons (e.g., comparing string field with number). Add validation for operator compatibility with field types. Create typed query methods like whereString(), whereNumber(), whereDate() for type safety. Ensure all validation happens at compile time without runtime overhead. Add comprehensive unit tests for type safety scenarios.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Create Authentication Layer",
        "description": "Implement comprehensive authentication support for API tokens, web auth tokens, and server-to-server authentication",
        "details": "Enhance existing AuthenticationMiddleware to support all three authentication methods. For server-to-server auth, implement ECDSA signing with P-256 keys using CryptoKit/Security framework. Create TokenManager protocol with implementations for each auth type. Add proper key rotation support and token refresh mechanisms. Implement request signing for server-to-server auth including proper header construction (X-Apple-CloudKit-Request-KeyID, X-Apple-CloudKit-Request-ISO8601Date, X-Apple-CloudKit-Request-SignatureV1). Use async/await for all authentication operations.",
        "testStrategy": "Test each authentication method independently. Mock CloudKit responses for auth validation. Test key rotation scenarios. Verify proper header construction and request signing. Test token expiration and refresh flows.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TokenManager Protocol and Base Types",
            "description": "Create the TokenManager protocol and supporting types for authentication management",
            "dependencies": [],
            "details": "Define a TokenManager protocol in Sources/MistKit/Authentication/TokenManager.swift with async methods for token validation, refresh, and retrieval. Create an AuthenticationMethod enum with cases for apiToken(String), webAuthToken(apiToken: String, webToken: String), and serverToServer(keyID: String, privateKey: Data). Create a TokenCredentials struct that encapsulates all authentication-related data. Ensure all types conform to Sendable for concurrent access safety.",
            "status": "pending",
            "testStrategy": "Unit test the protocol conformance with mock implementations. Test that all types are properly Sendable. Verify enum case creation and pattern matching works correctly."
          },
          {
            "id": 2,
            "title": "Implement API Token and Web Auth Token Managers",
            "description": "Create concrete implementations for API token and web authentication token management",
            "dependencies": [
              "5.1"
            ],
            "details": "Create APITokenManager and WebAuthTokenManager classes conforming to TokenManager protocol in Sources/MistKit/Authentication/. APITokenManager handles simple API token storage and validation. WebAuthTokenManager manages both API and web auth tokens, using the existing CharacterMapEncoder for web token encoding. Implement token validation logic checking for expiry if applicable. Add token refresh stub methods that can be extended later. Store tokens securely in memory with actor isolation for thread safety.",
            "status": "pending",
            "testStrategy": "Test token storage and retrieval. Verify CharacterMapEncoder is properly used for web tokens. Test concurrent access patterns with async/await. Mock token validation scenarios including expired tokens."
          },
          {
            "id": 3,
            "title": "Implement Server-to-Server Authentication with ECDSA",
            "description": "Build the server-to-server authentication manager with ECDSA P-256 signing",
            "dependencies": [
              "5.1"
            ],
            "details": "Create ServerToServerAuthManager in Sources/MistKit/Authentication/ServerToServerAuthManager.swift. Import CryptoKit for P-256 ECDSA operations. Implement private key loading from Data or PEM format. Create request signing method that generates ISO8601 timestamp, constructs the signature payload ([Current Date]:[Request Body]:[Web Service URL]), signs with P-256 private key, and returns base64-encoded signature. Implement header construction for X-Apple-CloudKit-Request-KeyID, X-Apple-CloudKit-Request-ISO8601Date, and X-Apple-CloudKit-Request-SignatureV1. Add key rotation support with multiple key storage.",
            "status": "pending",
            "testStrategy": "Test ECDSA signature generation with known test vectors. Verify ISO8601 date formatting matches CloudKit requirements. Test header construction with various request types. Mock key rotation scenarios. Test PEM key parsing and validation."
          },
          {
            "id": 4,
            "title": "Enhance AuthenticationMiddleware for All Methods",
            "description": "Update the existing AuthenticationMiddleware to support all three authentication methods",
            "dependencies": [
              "5.1",
              "5.2",
              "5.3"
            ],
            "details": "Refactor AuthenticationMiddleware to accept a TokenManager instance instead of MistKitConfiguration directly. Add authentication method detection based on configuration. For API/Web auth, maintain existing query parameter approach. For server-to-server, add request headers instead of query parameters. Implement async request signing for server-to-server auth before sending. Create factory method in MistKitConfiguration to instantiate appropriate TokenManager based on provided credentials. Ensure backward compatibility with existing API token authentication.",
            "status": "pending",
            "testStrategy": "Test middleware with each authentication method independently. Verify query parameters for API/Web auth and headers for server-to-server. Test request interception and modification. Verify backward compatibility with existing code."
          },
          {
            "id": 5,
            "title": "Add Token Refresh and Rotation Mechanisms",
            "description": "Implement automatic token refresh and key rotation capabilities",
            "dependencies": [
              "5.2",
              "5.3",
              "5.4"
            ],
            "details": "Add token refresh logic to WebAuthTokenManager using CloudKit's token refresh endpoints if available. Implement key rotation scheduler in ServerToServerAuthManager with configurable rotation intervals. Create TokenRefreshPolicy enum with options like onExpiry, periodic(TimeInterval), and manual. Add retry logic with exponential backoff for failed authentication attempts. Implement token/key storage interface for persistence (in-memory default, with protocol for custom storage). Add notification system for token refresh events using AsyncStream.",
            "status": "pending",
            "testStrategy": "Test automatic token refresh triggers. Verify key rotation at specified intervals. Test retry logic with various failure scenarios. Mock token expiry and refresh flows. Test AsyncStream notifications for refresh events."
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement Core CloudKit Operations",
        "description": "Build the main CloudKitService implementation with complete CRUD operations for records across all databases",
        "details": "Extend the existing CloudKitService to implement CloudKitServiceProtocol. Add support for all databases (public/private/shared) with proper access control validation. Implement record operations: create (with auto-generated recordName), update (with change tag validation), delete, batch operations with atomic flag support. Add proper error handling that maps CloudKit errors to typed Swift errors. Implement retry logic with exponential backoff for transient failures. Use URLSession with proper timeout configurations. Add telemetry hooks for monitoring.",
        "testStrategy": "Integration tests against CloudKit sandbox environment. Test CRUD operations in all databases. Verify atomic batch operations rollback on failure. Test conflict resolution with change tags. Test rate limiting and retry logic.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement CloudKitServiceProtocol conformance",
            "description": "Make CloudKitService conform to CloudKitServiceProtocol with all required method signatures",
            "dependencies": [],
            "details": "Update CloudKitService class to conform to CloudKitServiceProtocol. Add all required method signatures from the protocol including create, update, delete, and batch operations. Ensure proper async/await signatures and return types. Set up the foundation for implementing each operation with proper method stubs that throw notImplemented errors initially.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement record creation with auto-generated recordName",
            "description": "Build the create record operation with automatic recordName generation when not provided",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement createRecord method that accepts CloudKitRecord and database type. When recordName is nil, generate a UUID-based recordName. Convert CloudKitRecord to OpenAPI Components.Schemas.Record format. Use existing performRequest method to make the API call to /records/modify endpoint with 'create' operation. Handle successful response by returning the created CloudKitRecord with server-assigned metadata.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement record update with change tag validation",
            "description": "Build the update operation with proper change tag conflict detection and resolution",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement updateRecord method that requires recordChangeTag for optimistic concurrency control. Convert CloudKitRecord to API format ensuring change tag is included. Use /records/modify endpoint with 'update' operation. Handle conflict errors (serverRecordChanged) by returning appropriate error with server's current record. Implement optional forceOverwrite flag to bypass change tag validation when needed.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement delete and batch operations with atomic flag",
            "description": "Build single and batch delete operations with support for atomic transactions",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3"
            ],
            "details": "Implement deleteRecord for single deletions and batch methods for create/update/delete operations. Add atomic flag parameter that ensures all-or-nothing execution for batch operations. Structure batch requests using operations array with proper operation types. Handle partial failures when atomic is false by returning both successful and failed operations. When atomic is true, rollback all operations on any failure.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create CloudKit error mapping system",
            "description": "Build comprehensive error mapping from CloudKit API errors to typed Swift errors",
            "dependencies": [
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Create CloudKitError enum with cases for all CloudKit error types: serverRecordChanged, recordNotFound, invalidArguments, quotaExceeded, throttled, etc. Parse error responses from API including ckErrorCode and reason fields. Map HTTP status codes and CloudKit-specific error codes to appropriate Swift error cases. Include relevant metadata in errors like conflicting record for serverRecordChanged. Ensure errors conform to LocalizedError for user-friendly messages.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement retry logic with exponential backoff",
            "description": "Add intelligent retry mechanism for transient failures with configurable backoff strategy",
            "dependencies": [
              "6.5"
            ],
            "details": "Create RetryConfiguration with maxAttempts, baseDelay, maxDelay, and retryableErrors parameters. Implement exponential backoff algorithm with jitter to prevent thundering herd. Identify retryable errors: network failures, rate limiting (throttled), service unavailable. Use Task.sleep for delays between retries. Add retry attempt counter to request context for telemetry. Ensure proper cancellation support during retry delays.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add database validation and telemetry hooks",
            "description": "Implement database access validation and monitoring instrumentation points",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4",
              "6.5",
              "6.6"
            ],
            "details": "Add compile-time and runtime validation for database types ensuring private/shared operations require authentication. Create TelemetryProtocol with hooks for request start, completion, retry, and error events. Instrument all operations with telemetry calls including timing, database type, operation type, and result. Add configuration for telemetry providers (metrics, logging, tracing). Ensure telemetry doesn't impact performance with async fire-and-forget pattern.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Build mistk CLI Tool",
        "description": "Create comprehensive command-line tool for testing MistKit functionality and CloudKit operations",
        "details": "Use Swift ArgumentParser to build the CLI with subcommands for records, zones, subscriptions, users, assets, field-types, auth, stress, and benchmark. Implement configuration management for storing credentials. Add JSON/YAML output formats for scripting. Include progress indicators for long-running operations using Swift-Progress or similar. Implement parallel execution for stress testing using Swift concurrency TaskGroup. Add colorized output for better readability. Support for environment-based configuration (.mistk.yml). Consider using Swift-Log for structured logging.",
        "testStrategy": "Test all CLI commands with mock CloudKit responses. Verify configuration persistence. Test output formatting in different modes. Test stress testing with high concurrency. Verify proper error reporting and exit codes.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up CLI executable target with ArgumentParser",
            "description": "Create new executable target in Package.swift and configure Swift ArgumentParser as dependency",
            "dependencies": [],
            "details": "Add new executable target 'mistk' to Package.swift with ArgumentParser dependency. Create Sources/mistk directory structure with main.swift entry point. Set up basic CLI structure with @main attribute and ParsableCommand conformance. Configure package to build executable properly with release optimizations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement record management subcommands",
            "description": "Create CRUD operations for CloudKit records including create, read, update, delete, and query commands",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement RecordCommand with subcommands: create-record, get-record, update-record, delete-record, query-records. Each command should accept parameters like record-type, record-id, fields (as JSON), zone-id, database type. Use MistKitClient for actual CloudKit operations. Add proper error handling and result display.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add zone and subscription management commands",
            "description": "Implement commands for managing CloudKit zones and subscriptions",
            "dependencies": [
              "7.1"
            ],
            "details": "Create ZoneCommand with list-zones, create-zone, delete-zone subcommands. Implement SubscriptionCommand with list-subscriptions, create-subscription, modify-subscription, delete-subscription. Support both record and database subscriptions. Handle notification configuration including notification info and trigger conditions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create asset upload and download commands",
            "description": "Build commands for handling CloudKit asset operations including upload, download, and management",
            "dependencies": [
              "7.1"
            ],
            "details": "Implement AssetCommand with upload-asset, download-asset subcommands. Support file path input for uploads and output directory for downloads. Add progress indicators during transfer using Swift-Progress or custom implementation. Handle multipart uploads for large files. Support resume capability for interrupted transfers.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement authentication configuration management",
            "description": "Create secure credential storage and management system for different authentication methods",
            "dependencies": [
              "7.1"
            ],
            "details": "Build AuthCommand with configure, list-configs, switch-config, remove-config subcommands. Implement secure keychain storage on macOS and file-based storage with encryption on Linux. Support API token, web auth token, and server-to-server key configurations. Create ConfigManager to handle .mistk.yml file parsing and environment variable overrides.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add stress testing and benchmark commands",
            "description": "Implement performance testing capabilities with configurable load patterns",
            "dependencies": [
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Create StressCommand with parameters for concurrent operations, duration, operation types. Implement BenchmarkCommand for measuring latency and throughput. Use TaskGroup for parallel execution with configurable concurrency levels. Generate performance reports with statistics (p50, p95, p99 latencies). Support different load patterns: constant, ramp-up, spike.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement output formatters for JSON and YAML",
            "description": "Create flexible output formatting system for different output modes",
            "dependencies": [
              "7.1"
            ],
            "details": "Build OutputFormatter protocol with JSONFormatter and YAMLFormatter implementations. Add --output-format flag globally to all commands. Implement pretty-printing for human-readable output. Support compact JSON for scripting. Add table output format for list operations using TextTable or similar. Ensure proper encoding of special characters and CloudKit types.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Add progress indicators and colorized output",
            "description": "Enhance CLI UX with visual feedback for operations and colored terminal output",
            "dependencies": [
              "7.7"
            ],
            "details": "Integrate progress indicator library or build custom using ANSI escape codes. Show progress bars for file uploads/downloads and batch operations. Implement color coding: green for success, red for errors, yellow for warnings. Add spinner for indeterminate operations. Support --no-color flag for CI environments. Use Swift-Log for structured logging with configurable verbosity levels.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Create configuration file support and help system",
            "description": "Implement .mistk.yml configuration loading and comprehensive help documentation",
            "dependencies": [
              "7.5",
              "7.8"
            ],
            "details": "Parse .mistk.yml from current directory, home directory, or specified path. Support environment variable substitution in config files. Implement config validation with helpful error messages. Generate comprehensive help text for all commands with examples. Add --dry-run flag for testing commands without execution. Create shell completion scripts for bash/zsh/fish.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Advanced Features",
        "description": "Add zone management, subscriptions, asset handling, and record changes tracking",
        "details": "Implement zone operations (create, delete, list) for private database only with compile-time database validation. Add subscription management for push notifications using CKSubscription types. Implement asset upload/download with progress tracking, using URLSession for uploads and multipart form data. Add record changes API for incremental sync with change tokens. Implement proper pagination with continuation tokens. Add support for record shares in shared database. Use AsyncStream for real-time updates.",
        "testStrategy": "Test zone lifecycle operations. Verify subscription creation and modification. Test asset upload with various file sizes. Test incremental sync with change tokens. Verify pagination across large datasets.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Zone Management for Private Database",
            "description": "Create zone operations including creation, deletion, and listing for private database only",
            "dependencies": [],
            "details": "Build RecordZone struct matching CloudKit's CKRecordZone with zoneID and capabilities. Implement CloudKitService extensions for createZone(), deleteZone(), and listZones() methods for private database only. Add compile-time validation to ensure zone operations are only called on private database using @available or generic constraints. Map OpenAPI Components.Schemas.Zone to internal zone types. Handle zone-specific errors like zoneNotFound and quotaExceeded.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Add Compile-Time Database Validation for Zones",
            "description": "Implement type-safe compile-time checks ensuring zone operations only work with private database",
            "dependencies": [
              "8.1"
            ],
            "details": "Create DatabaseType enum with associated zone capabilities. Use Swift generics and protocol constraints to prevent zone operations on public/shared databases at compile time. Implement ZoneCapable protocol that only PrivateDatabase conforms to. Add compiler diagnostics with helpful error messages when attempting zone operations on incompatible databases. Consider using phantom types for additional type safety.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Subscription Management System",
            "description": "Build comprehensive subscription management for push notifications using CKSubscription patterns",
            "dependencies": [],
            "details": "Implement CloudKitSubscription struct with subscription types (query, record zone, database). Create SubscriptionNotificationInfo with alertBody, soundName, shouldBadge properties. Build subscription CRUD operations: createSubscription(), modifySubscription(), deleteSubscription(), listSubscriptions(). Support subscription filters using existing RecordQuery system. Add proper subscription ID management and handle subscription limits per database.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Asset Upload with Multipart Form Data",
            "description": "Create asset upload functionality using URLSession with multipart/form-data encoding",
            "dependencies": [],
            "details": "Build MultipartFormDataBuilder for constructing multipart requests with boundaries. Implement CloudKitAsset struct with fileURL, data, and metadata properties. Create uploadAsset() method that constructs proper multipart request with asset tokens. Handle large file uploads with URLSession's uploadTask for memory efficiency. Add support for asset field references in CloudKitRecord. Implement proper Content-Type and boundary generation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Add Asset Download with Progress Tracking",
            "description": "Implement asset download functionality with real-time progress updates",
            "dependencies": [
              "8.4"
            ],
            "details": "Create downloadAsset() method using URLSession downloadTask for efficient file handling. Implement DownloadProgress struct with bytesReceived, totalBytes, and percentage. Use Combine publishers or AsyncStream to emit progress updates during download. Add resume capability for interrupted downloads using ETags. Implement proper file management for downloaded assets with temporary and final locations. Handle asset URL expiration and refresh.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Record Changes API with Change Tokens",
            "description": "Build incremental sync functionality using CloudKit's changes API and change tokens",
            "dependencies": [],
            "details": "Implement fetchRecordChanges() method accepting previousServerChangeToken parameter. Create ChangeToken wrapper for proper token persistence and management. Build RecordChangeset struct containing changed, deleted records and new changeToken. Handle moreComing flag for paginated change results. Implement proper change token storage strategy (UserDefaults, Keychain, or custom). Add conflict resolution for concurrent modifications.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add Incremental Sync Support",
            "description": "Create high-level incremental sync mechanism built on top of record changes API",
            "dependencies": [
              "8.6"
            ],
            "details": "Build SyncEngine class managing sync state and change tokens per database/zone. Implement automatic change detection and sync scheduling. Create SyncConflictResolver protocol for handling conflicts during sync. Add support for sync anchors and checkpoints for reliable sync resume. Implement batch processing for efficient sync of large changesets. Handle sync errors with appropriate retry strategies.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement Pagination with Continuation Tokens",
            "description": "Add comprehensive pagination support using CloudKit's continuation tokens",
            "dependencies": [],
            "details": "Enhance query operations to return PagedResult containing records and continuationMarker. Implement automatic pagination handling in list operations using AsyncSequence. Create PaginationOptions struct with resultsLimit and desiredKeys. Handle continuation tokens properly across API calls. Add support for cursor-based pagination in RecordQuery. Implement efficient memory management for large result sets.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add Record Shares Support for Shared Database",
            "description": "Implement record sharing functionality specific to CloudKit's shared database",
            "dependencies": [],
            "details": "Create CloudKitShare struct representing CKShare with participants and permissions. Implement createShare(), acceptShare(), and fetchShareMetadata() operations. Build ShareParticipant struct with userIdentity, permission, and acceptance status. Add support for share URLs and share acceptance flow. Implement proper permission management (owner, readWrite, readOnly). Handle share-specific errors and limits.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Create AsyncStream for Real-Time Updates",
            "description": "Implement real-time update streaming using Swift's AsyncStream",
            "dependencies": [
              "8.3",
              "8.6",
              "8.7"
            ],
            "details": "Build CloudKitUpdateStream using AsyncStream for real-time record updates. Implement long-polling or WebSocket connection for receiving push notifications. Create UpdateEvent enum for different event types (recordChanged, recordDeleted, subscriptionTriggered). Add automatic reconnection logic with exponential backoff. Implement stream filtering based on record types or zones. Handle stream lifecycle properly with cancellation support.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Create Testing Infrastructure",
        "description": "Build comprehensive testing framework including unit tests, integration tests, and OpenAPI validation",
        "details": "Create XCTest suites for all components with >90% code coverage. Build mock CloudKit server using Swift NIO for integration testing. Implement OpenAPI contract testing to validate our spec against live CloudKit APIs. Create performance benchmarks using XCTest's measure APIs. Add property-based testing using SwiftCheck for field type conversions. Implement continuous validation pipeline that runs daily against CloudKit staging. Create test fixtures for all CloudKit response types. Add mutation testing to verify test quality.",
        "testStrategy": "Unit tests for all public APIs, integration tests with mock server, contract tests against live CloudKit, performance benchmarks for critical paths, property-based tests for type conversions, daily validation against CloudKit staging environment.",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create XCTest suite structure and base test classes",
            "description": "Set up comprehensive XCTest infrastructure with base test classes, helpers, and utilities for all test types",
            "dependencies": [],
            "details": "Create Tests/MistKitTests directory structure with subdirectories for unit, integration, contract, and performance tests. Develop base test classes (MistKitTestCase, MistKitIntegrationTestCase) with common setup/teardown logic. Implement test helpers for creating mock CloudKit responses, test fixtures, and common assertions. Set up XCTest configuration files for different test scenarios (unit only, integration, full suite). Create test data builders using the builder pattern for easy test data creation.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Build mock CloudKit server using Swift NIO",
            "description": "Implement a fully-featured mock CloudKit server that simulates CloudKit Web Services API responses",
            "dependencies": [
              "9.1"
            ],
            "details": "Create MockCloudKitServer using Swift NIO HTTP server components. Implement all CloudKit Web Services endpoints from the OpenAPI spec including records/query, records/modify, zones/list, etc. Add configurable response delays to simulate network latency. Support both success and error responses with proper CloudKit error format. Implement in-memory data storage for testing stateful operations. Add request validation to ensure proper authentication headers and request format. Create server configuration options for different test scenarios.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement OpenAPI contract testing framework",
            "description": "Create contract testing system to validate MistKit against the CloudKit OpenAPI specification",
            "dependencies": [
              "9.1"
            ],
            "details": "Integrate swift-openapi-runtime testing utilities for contract validation. Create ContractTestCase base class that loads OpenAPI spec and validates requests/responses. Implement request interceptor to capture and validate outgoing requests against OpenAPI schema. Build response validator to ensure CloudKit responses match expected schema. Add contract test generator that creates tests from OpenAPI paths automatically. Implement differential testing between mock server and live CloudKit API. Create reporting system for contract violations.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add performance benchmarks with XCTest measure APIs",
            "description": "Create comprehensive performance testing suite for critical operations",
            "dependencies": [
              "9.1"
            ],
            "details": "Implement performance tests for record serialization/deserialization using XCTest.measure. Create benchmarks for batch operations (saveRecords, deleteRecords) with varying batch sizes. Add memory usage tests using XCTMemoryMetric for large dataset handling. Benchmark query performance with different filter complexities. Test concurrent operation performance using TaskGroup operations. Create baseline metrics file for regression detection. Implement performance test reports with historical trend tracking.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Integrate SwiftCheck for property-based testing",
            "description": "Add property-based testing for field type conversions and data validation",
            "dependencies": [
              "9.1"
            ],
            "details": "Add SwiftCheck as a test dependency in Package.swift. Create Arbitrary instances for all FieldValue types including list variants. Implement property tests for FieldValue encoding/decoding roundtrips. Add invariant testing for CloudKitRecord transformations. Create generators for valid and invalid CloudKit field names. Test edge cases in date conversions (milliseconds to Date). Verify Location coordinate bounds and precision handling. Test Reference and Asset URL validation properties.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Create comprehensive test fixtures for CloudKit responses",
            "description": "Build a complete library of test fixtures covering all CloudKit response types and edge cases",
            "dependencies": [
              "9.1"
            ],
            "details": "Create JSON fixture files for all CloudKit response types from the OpenAPI spec. Include success responses, error responses, and edge cases for each endpoint. Build fixture loader utility that can load and parse JSON fixtures. Create parameterized fixtures for different record types and field combinations. Add fixtures for pagination scenarios with continuation tokens. Include fixtures for all CloudKit error codes and formats. Create fixture builder DSL for dynamically generating test data. Organize fixtures by feature area (records, zones, assets, etc.).",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Set up continuous validation pipeline",
            "description": "Implement automated daily validation against CloudKit staging environment",
            "dependencies": [
              "9.3",
              "9.6"
            ],
            "details": "Create ValidationTestSuite that runs against live CloudKit staging environment. Implement test container setup/teardown for isolated testing. Add GitHub Actions workflow for daily validation runs. Create test data seeding mechanism for consistent test environment. Implement validation for all CRUD operations against real CloudKit. Add response time monitoring and alerting for performance regressions. Create validation report generator with pass/fail metrics. Set up notification system for validation failures.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement mutation testing framework",
            "description": "Add mutation testing to verify test suite quality and effectiveness",
            "dependencies": [
              "9.1",
              "9.5"
            ],
            "details": "Integrate muter or similar Swift mutation testing tool. Configure mutation operators for Swift-specific constructs. Create mutation test configuration targeting critical code paths. Implement mutation score tracking and reporting. Add pre-commit hook for mutation testing on changed files. Create allowlist for acceptable surviving mutants. Generate mutation testing reports with killed/survived mutant details. Set minimum mutation score thresholds for CI/CD pipeline.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Create integration test suite against sandbox",
            "description": "Build end-to-end integration tests running against CloudKit sandbox environment",
            "dependencies": [
              "9.2",
              "9.6",
              "9.7"
            ],
            "details": "Set up CloudKit sandbox container configuration for integration testing. Create IntegrationTestCase base class with sandbox setup/cleanup. Implement full user journey tests (create account, CRUD operations, queries). Add multi-user collaboration tests for shared database operations. Test rate limiting and retry mechanisms with actual CloudKit throttling. Verify authentication flows including token refresh scenarios. Test large batch operations approaching CloudKit limits. Create integration test data cleanup utilities.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Achieve and maintain >90% code coverage",
            "description": "Implement comprehensive unit tests to reach and sustain >90% code coverage target",
            "dependencies": [
              "9.1",
              "9.4",
              "9.5",
              "9.8"
            ],
            "details": "Configure swift-test with --enable-code-coverage flag in CI/CD. Create coverage report generation using llvm-cov or xcov. Identify and test all uncovered code paths systematically. Add unit tests for all public APIs and internal utilities. Implement edge case testing for error handling paths. Create coverage enforcement rules in pull request checks. Set up coverage trend tracking and visualization. Add coverage badges to README and documentation. Create excluded paths configuration for generated code.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Create Documentation and Examples",
        "description": "Build comprehensive documentation, migration guides, and example applications",
        "details": "Generate API documentation using DocC with full type documentation and code examples. Create migration guide from CloudKit framework to MistKit. Build server-side web application demo using Hummingbird 2.0 or Vapor 5 showcasing all features including real-time updates via WebSockets. Enhance existing MistDemo with full CRUD operations. Create Swift Playgrounds for interactive learning. Write performance optimization guide with caching strategies using Swift-Cache or similar. Create troubleshooting guide for common CloudKit errors. Add inline documentation for all public APIs with usage examples.",
        "testStrategy": "Verify all code examples compile and run correctly. Test documentation generation with DocC. Validate example applications work with real CloudKit containers. Test migration guide procedures with sample projects.",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up DocC documentation infrastructure",
            "description": "Configure DocC for the MistKit package and establish documentation structure with proper organization",
            "dependencies": [],
            "details": "Install and configure DocC in Package.swift. Create documentation catalog structure at Sources/MistKit/MistKit.docc. Set up documentation landing page with package overview. Configure build scripts for generating documentation. Add GitHub Actions workflow for automated documentation deployment to GitHub Pages. Create custom DocC theme matching MistKit branding. Set up documentation versioning strategy.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Write comprehensive API documentation",
            "description": "Document all public APIs with detailed descriptions, code examples, and usage guidelines",
            "dependencies": [
              "10.1"
            ],
            "details": "Add documentation comments to all public types, methods, and properties using DocC syntax. Include code snippets demonstrating common use cases for each API. Document all FieldValue types with examples of encoding/decoding. Create articles explaining authentication flows for each auth method. Document error handling patterns and recovery strategies. Add documentation for async/await patterns and concurrency considerations. Include deprecation notices and migration paths where applicable.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create CloudKit to MistKit migration guide",
            "description": "Build comprehensive guide for developers migrating from CloudKit framework to MistKit",
            "dependencies": [
              "10.2"
            ],
            "details": "Create side-by-side comparison of CloudKit framework vs MistKit APIs. Document mapping between CKRecord and MistKit's Record types. Explain differences in authentication approaches. Provide step-by-step migration checklist for common scenarios. Include code transformation examples for typical CloudKit operations. Address platform-specific considerations for iOS/macOS to server migration. Create troubleshooting section for common migration issues.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Build server-side demo application",
            "description": "Create full-featured server application using Vapor or Hummingbird showcasing MistKit capabilities",
            "dependencies": [
              "10.2"
            ],
            "details": "Set up Vapor 5 or Hummingbird 2.0 project with MistKit integration. Implement REST API endpoints for CRUD operations using MistKit. Add WebSocket support for real-time CloudKit change notifications. Create user authentication flow with CloudKit user discovery. Implement file upload/download with CloudKit assets. Add caching layer using Swift-Cache for performance optimization. Include Docker configuration for easy deployment. Create comprehensive README with setup instructions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Enhance MistDemo and create Swift Playgrounds",
            "description": "Expand existing demo app and create interactive learning materials",
            "dependencies": [
              "10.2"
            ],
            "details": "Enhance MistDemo with full CRUD operations for all field types. Add UI for testing batch operations and atomic transactions. Implement subscription handling with real-time updates. Create Swift Playgrounds demonstrating each MistKit feature interactively. Build playground pages for authentication, queries, subscriptions, and assets. Add inline tutorials explaining CloudKit concepts. Include performance testing scenarios in demo app. Create sample data generators for testing.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Write optimization and troubleshooting guides",
            "description": "Create comprehensive guides for performance optimization and common issue resolution",
            "dependencies": [
              "10.2",
              "10.4",
              "10.5"
            ],
            "details": "Write performance optimization guide covering caching strategies with Swift-Cache, batch operation best practices, and query optimization techniques. Document rate limiting handling and retry strategies. Create troubleshooting guide for common CloudKit errors with solutions. Include debugging techniques for authentication issues. Document network optimization for large asset transfers. Add monitoring and logging best practices. Create decision tree for choosing between public/private/shared databases. Include CloudKit quota management strategies.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-08-15T00:05:03.986Z",
      "updated": "2025-08-22T16:39:31.562Z",
      "description": "Tasks for master context"
    }
  }
}