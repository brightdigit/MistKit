import HTTPTypes
// periphery:ignore:all
// swift-format-ignore-file
// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime

#if os(Linux)
  @preconcurrency import struct Foundation.URL
  @preconcurrency import struct Foundation.Data
  @preconcurrency import struct Foundation.Date
#else
  import struct Foundation.URL
  import struct Foundation.Data
  import struct Foundation.Date
#endif
/// CloudKit web services provides an HTTP interface to fetch, create, update, and delete records, zones, and subscriptions.
/// You also have access to discoverable users and contacts.
///
/// ## Authentication
/// There are two authentication methods:
/// 1. API Token Authentication - Use query parameters: `?ckAPIToken=[API token]&ckWebAuthToken=[Web Auth Token]`
/// 2. Server-to-Server Key Authentication - Pass the key ID as `X-Apple-CloudKit-Request-KeyID` header
///
/// ## Base URL Structure
/// `https://api.apple-cloudkit.com/database/{version}/{container}/{environment}/{database}/{operation}`
///
/// Where:
/// - version: Protocol version (currently "1")
/// - container: Unique identifier for the app's container (begins with "iCloud.")
/// - environment: "development" or "production"
/// - database: "public", "private", or "shared"
///
internal struct Client: APIProtocol {
  /// The underlying HTTP client.
  private let client: UniversalClient
  /// Creates a new client.
  /// - Parameters:
  ///   - serverURL: The server URL that the client connects to. Any server
  ///   URLs defined in the OpenAPI document are available as static methods
  ///   on the ``Servers`` type.
  ///   - configuration: A set of configuration values for the client.
  ///   - transport: A transport that performs HTTP operations.
  ///   - middlewares: A list of middlewares to call before the transport.
  internal init(
    serverURL: Foundation.URL,
    configuration: Configuration = .init(),
    transport: any ClientTransport,
    middlewares: [any ClientMiddleware] = []
  ) {
    self.client = .init(
      serverURL: serverURL,
      configuration: configuration,
      transport: transport,
      middlewares: middlewares
    )
  }
  private var converter: Converter {
    client.converter
  }
  /// Query Records
  ///
  /// Fetch records using a query with filters and sorting options
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/records/query`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/records/query/post(queryRecords)`.
  internal func queryRecords(_ input: Operations.queryRecords.Input) async throws
    -> Operations.queryRecords.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.queryRecords.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/records/query",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.queryRecords.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.QueryResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        case 403:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Forbidden.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .forbidden(.init(body: body))
        case 404:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(body: body))
        case 409:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Conflict.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .conflict(.init(body: body))
        case 412:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.PreconditionFailed.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .preconditionFailed(.init(body: body))
        case 413:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.RequestEntityTooLarge.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .contentTooLarge(.init(body: body))
        case 429:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.TooManyRequests.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .tooManyRequests(.init(body: body))
        case 421:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.UnprocessableEntity.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .misdirectedRequest(.init(body: body))
        case 500:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.InternalServerError.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .internalServerError(.init(body: body))
        case 503:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.ServiceUnavailable.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .serviceUnavailable(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Modify Records
  ///
  /// Create, update, or delete records (supports bulk operations)
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/records/modify`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/records/modify/post(modifyRecords)`.
  internal func modifyRecords(_ input: Operations.modifyRecords.Input) async throws
    -> Operations.modifyRecords.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.modifyRecords.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/records/modify",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.modifyRecords.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ModifyResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        case 403:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Forbidden.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .forbidden(.init(body: body))
        case 404:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(body: body))
        case 409:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Conflict.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .conflict(.init(body: body))
        case 412:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.PreconditionFailed.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .preconditionFailed(.init(body: body))
        case 413:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.RequestEntityTooLarge.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .contentTooLarge(.init(body: body))
        case 429:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.TooManyRequests.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .tooManyRequests(.init(body: body))
        case 421:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.UnprocessableEntity.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .misdirectedRequest(.init(body: body))
        case 500:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.InternalServerError.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .internalServerError(.init(body: body))
        case 503:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.ServiceUnavailable.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .serviceUnavailable(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Lookup Records
  ///
  /// Fetch specific records by their IDs
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/records/lookup`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/records/lookup/post(lookupRecords)`.
  internal func lookupRecords(_ input: Operations.lookupRecords.Input) async throws
    -> Operations.lookupRecords.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.lookupRecords.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/records/lookup",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.lookupRecords.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.LookupResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        case 403:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Forbidden.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .forbidden(.init(body: body))
        case 404:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(body: body))
        case 409:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Conflict.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .conflict(.init(body: body))
        case 412:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.PreconditionFailed.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .preconditionFailed(.init(body: body))
        case 413:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.RequestEntityTooLarge.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .contentTooLarge(.init(body: body))
        case 429:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.TooManyRequests.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .tooManyRequests(.init(body: body))
        case 421:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.UnprocessableEntity.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .misdirectedRequest(.init(body: body))
        case 500:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.InternalServerError.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .internalServerError(.init(body: body))
        case 503:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.ServiceUnavailable.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .serviceUnavailable(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Fetch Record Changes
  ///
  /// Get all record changes relative to a sync token
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/records/changes`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/records/changes/post(fetchRecordChanges)`.
  internal func fetchRecordChanges(_ input: Operations.fetchRecordChanges.Input) async throws
    -> Operations.fetchRecordChanges.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.fetchRecordChanges.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/records/changes",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.fetchRecordChanges.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ChangesResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        case 403:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Forbidden.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .forbidden(.init(body: body))
        case 404:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(body: body))
        case 409:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Conflict.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .conflict(.init(body: body))
        case 412:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.PreconditionFailed.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .preconditionFailed(.init(body: body))
        case 413:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.RequestEntityTooLarge.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .contentTooLarge(.init(body: body))
        case 429:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.TooManyRequests.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .tooManyRequests(.init(body: body))
        case 421:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.UnprocessableEntity.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .misdirectedRequest(.init(body: body))
        case 500:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.InternalServerError.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .internalServerError(.init(body: body))
        case 503:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.ServiceUnavailable.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .serviceUnavailable(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// List All Zones
  ///
  /// Fetch all zones in the database
  ///
  /// - Remark: HTTP `GET /database/{version}/{container}/{environment}/{database}/zones/list`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/zones/list/get(listZones)`.
  internal func listZones(_ input: Operations.listZones.Input) async throws
    -> Operations.listZones.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.listZones.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/zones/list",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.listZones.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ZonesListResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        case 403:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Forbidden.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .forbidden(.init(body: body))
        case 404:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(body: body))
        case 409:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Conflict.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .conflict(.init(body: body))
        case 412:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.PreconditionFailed.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .preconditionFailed(.init(body: body))
        case 413:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.RequestEntityTooLarge.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .contentTooLarge(.init(body: body))
        case 429:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.TooManyRequests.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .tooManyRequests(.init(body: body))
        case 421:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.UnprocessableEntity.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .misdirectedRequest(.init(body: body))
        case 500:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.InternalServerError.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .internalServerError(.init(body: body))
        case 503:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.ServiceUnavailable.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .serviceUnavailable(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Lookup Zones
  ///
  /// Fetch specific zones by their IDs
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/zones/lookup`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/zones/lookup/post(lookupZones)`.
  internal func lookupZones(_ input: Operations.lookupZones.Input) async throws
    -> Operations.lookupZones.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.lookupZones.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/zones/lookup",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.lookupZones.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ZonesLookupResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Modify Zones
  ///
  /// Create or delete zones (only supported in private database)
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/zones/modify`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/zones/modify/post(modifyZones)`.
  internal func modifyZones(_ input: Operations.modifyZones.Input) async throws
    -> Operations.modifyZones.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.modifyZones.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/zones/modify",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.modifyZones.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ZonesModifyResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Fetch Zone Changes
  ///
  /// Get all changed zones relative to a meta-sync token
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/zones/changes`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/zones/changes/post(fetchZoneChanges)`.
  internal func fetchZoneChanges(_ input: Operations.fetchZoneChanges.Input) async throws
    -> Operations.fetchZoneChanges.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.fetchZoneChanges.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/zones/changes",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.fetchZoneChanges.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ZoneChangesResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// List All Subscriptions
  ///
  /// Fetch all subscriptions in the database
  ///
  /// - Remark: HTTP `GET /database/{version}/{container}/{environment}/{database}/subscriptions/list`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/subscriptions/list/get(listSubscriptions)`.
  internal func listSubscriptions(_ input: Operations.listSubscriptions.Input) async throws
    -> Operations.listSubscriptions.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.listSubscriptions.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/subscriptions/list",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.listSubscriptions.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.SubscriptionsListResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Lookup Subscriptions
  ///
  /// Fetch specific subscriptions by their IDs
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/subscriptions/lookup`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/subscriptions/lookup/post(lookupSubscriptions)`.
  internal func lookupSubscriptions(_ input: Operations.lookupSubscriptions.Input) async throws
    -> Operations.lookupSubscriptions.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.lookupSubscriptions.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/subscriptions/lookup",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.lookupSubscriptions.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.SubscriptionsLookupResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Modify Subscriptions
  ///
  /// Create, update, or delete subscriptions
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/subscriptions/modify`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/subscriptions/modify/post(modifySubscriptions)`.
  internal func modifySubscriptions(_ input: Operations.modifySubscriptions.Input) async throws
    -> Operations.modifySubscriptions.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.modifySubscriptions.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/subscriptions/modify",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.modifySubscriptions.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.SubscriptionsModifyResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Get Current User
  ///
  /// Fetch the current authenticated user's information
  ///
  /// - Remark: HTTP `GET /database/{version}/{container}/{environment}/{database}/users/current`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/users/current/get(getCurrentUser)`.
  internal func getCurrentUser(_ input: Operations.getCurrentUser.Input) async throws
    -> Operations.getCurrentUser.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.getCurrentUser.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/users/current",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .get
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        return (request, nil)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.getCurrentUser.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.UserResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        case 403:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Forbidden.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .forbidden(.init(body: body))
        case 404:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.NotFound.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .notFound(.init(body: body))
        case 409:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Conflict.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .conflict(.init(body: body))
        case 412:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.PreconditionFailed.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .preconditionFailed(.init(body: body))
        case 413:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.RequestEntityTooLarge.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .contentTooLarge(.init(body: body))
        case 429:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.TooManyRequests.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .tooManyRequests(.init(body: body))
        case 421:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.UnprocessableEntity.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .misdirectedRequest(.init(body: body))
        case 500:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.InternalServerError.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .internalServerError(.init(body: body))
        case 503:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.ServiceUnavailable.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .serviceUnavailable(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Discover User Identities
  ///
  /// Discover all user identities based on email addresses or user record names
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/users/discover`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/users/discover/post(discoverUserIdentities)`.
  internal func discoverUserIdentities(_ input: Operations.discoverUserIdentities.Input)
    async throws -> Operations.discoverUserIdentities.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.discoverUserIdentities.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/users/discover",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.discoverUserIdentities.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.DiscoverResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Lookup Contacts (Deprecated)
  ///
  /// Fetch contacts (This endpoint is deprecated)
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/users/lookup/contacts`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/users/lookup/contacts/post(lookupContacts)`.
  @available(*, deprecated)
  internal func lookupContacts(_ input: Operations.lookupContacts.Input) async throws
    -> Operations.lookupContacts.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.lookupContacts.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/users/lookup/contacts",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.lookupContacts.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ContactsResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Upload Assets
  ///
  /// Upload binary assets to CloudKit
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/assets/upload`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/assets/upload/post(uploadAssets)`.
  internal func uploadAssets(_ input: Operations.uploadAssets.Input) async throws
    -> Operations.uploadAssets.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.uploadAssets.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/assets/upload",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .multipartForm(value):
          body = try converter.setRequiredRequestBodyAsMultipart(
            value,
            headerFields: &request.headerFields,
            contentType: "multipart/form-data",
            allowsUnknownParts: true,
            requiredExactlyOncePartNames: [],
            requiredAtLeastOncePartNames: [],
            atMostOncePartNames: [
              "file"
            ],
            zeroOrMoreTimesPartNames: [],
            encoding: { part in
              switch part {
              case let .file(wrapped):
                var headerFields: HTTPTypes.HTTPFields = .init()
                let value = wrapped.payload
                let body = try converter.setRequiredRequestBodyAsBinary(
                  value.body,
                  headerFields: &headerFields,
                  contentType: "application/octet-stream"
                )
                return .init(
                  name: "file",
                  filename: wrapped.filename,
                  headerFields: headerFields,
                  body: body
                )
              case let .undocumented(value):
                return value
              }
            }
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.uploadAssets.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.AssetUploadResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Create APNs Token
  ///
  /// Create an Apple Push Notification service (APNs) token
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/tokens/create`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/tokens/create/post(createToken)`.
  internal func createToken(_ input: Operations.createToken.Input) async throws
    -> Operations.createToken.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.createToken.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/tokens/create",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Operations.createToken.Output.Ok.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.TokenResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .ok(.init(body: body))
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
  /// Register Token
  ///
  /// Register a token for push notifications
  ///
  /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/tokens/register`.
  /// - Remark: Generated from `#/paths//database/{version}/{container}/{environment}/{database}/tokens/register/post(registerToken)`.
  internal func registerToken(_ input: Operations.registerToken.Input) async throws
    -> Operations.registerToken.Output
  {
    try await client.send(
      input: input,
      forOperation: Operations.registerToken.id,
      serializer: { input in
        let path = try converter.renderedPath(
          template: "/database/{}/{}/{}/{}/tokens/register",
          parameters: [
            input.path.version,
            input.path.container,
            input.path.environment,
            input.path.database,
          ]
        )
        var request: HTTPTypes.HTTPRequest = .init(
          soar_path: path,
          method: .post
        )
        suppressMutabilityWarning(&request)
        converter.setAcceptHeader(
          in: &request.headerFields,
          contentTypes: input.headers.accept
        )
        let body: OpenAPIRuntime.HTTPBody?
        switch input.body {
        case let .json(value):
          body = try converter.setRequiredRequestBodyAsJSON(
            value,
            headerFields: &request.headerFields,
            contentType: "application/json; charset=utf-8"
          )
        }
        return (request, body)
      },
      deserializer: { response, responseBody in
        switch response.status.code {
        case 200:
          return .ok(.init())
        case 400:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.BadRequest.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .badRequest(.init(body: body))
        case 401:
          let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
          let body: Components.Responses.Unauthorized.Body
          let chosenContentType = try converter.bestContentType(
            received: contentType,
            options: [
              "application/json"
            ]
          )
          switch chosenContentType {
          case "application/json":
            body = try await converter.getResponseBodyAsJSON(
              Components.Schemas.ErrorResponse.self,
              from: responseBody,
              transforming: { value in
                .json(value)
              }
            )
          default:
            preconditionFailure("bestContentType chose an invalid content type.")
          }
          return .unauthorized(.init(body: body))
        default:
          return .undocumented(
            statusCode: response.status.code,
            .init(
              headerFields: response.headerFields,
              body: responseBody
            )
          )
        }
      }
    )
  }
}
