# Generated Code Structure Analysis

A deep dive into the Swift code generated by swift-openapi-generator, with annotated examples showing type safety, architecture patterns, and integration points.

## Overview

The swift-openapi-generator produces **10,476 lines** of type-safe Swift code from the CloudKit Web Services OpenAPI specification. This article provides a detailed analysis of the generated code structure, explaining how it achieves compile-time safety, handles HTTP operations, and integrates with MistKit's wrapper layer.

## Generated File Organization

### File Structure

```
Sources/MistKit/Generated/
├── Client.swift      (3,268 lines) - API client implementation
└── Types.swift       (7,208 lines) - Type definitions
```

### File Headers

Both generated files include important header comments:

```swift
// Generated by swift-openapi-generator, do not modify.
// periphery:ignore:all
// swift-format-ignore-file
@_spi(Generated) import OpenAPIRuntime
```

**Header elements explained:**

- **`// Generated by swift-openapi-generator, do not modify.`**
  Warning to developers not to edit generated code (changes would be overwritten)

- **`// periphery:ignore:all`**
  Instructs [Periphery](https://github.com/peripheryapp/periphery) (dead code analyzer) to skip this file, avoiding false positives for unused methods

- **`// swift-format-ignore-file`**
  Prevents [swift-format](https://github.com/apple/swift-format) from reformatting generated code

- **`@_spi(Generated) import OpenAPIRuntime`**
  Imports internal/SPI (System Programming Interface) APIs from OpenAPIRuntime needed for generation

## Client.swift: API Client Implementation

### 1. APIProtocol: The Contract

The `APIProtocol` defines the complete API surface as a Sendable protocol:

```swift
/// A type that performs HTTP operations defined by the OpenAPI document.
internal protocol APIProtocol: Sendable {
    /// Query Records
    ///
    /// Fetch records using a query with filters and sorting options
    ///
    /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/records/query`.
    /// - Remark: Generated from `#/paths//database/.../records/query/post(queryRecords)`.
    func queryRecords(_ input: Operations.queryRecords.Input) async throws
        -> Operations.queryRecords.Output

    /// Modify Records
    ///
    /// Create, update, or delete records (supports bulk operations)
    ///
    /// - Remark: HTTP `POST /database/{version}/{container}/{environment}/{database}/records/modify`.
    func modifyRecords(_ input: Operations.modifyRecords.Input) async throws
        -> Operations.modifyRecords.Output

    // ... 13 more operations (15 total)
}
```

**Key characteristics:**

- ✅ **Sendable conformance**: Thread-safe by default for Swift 6 concurrency
- ✅ **Async/await**: All operations use modern concurrency
- ✅ **Typed errors**: `throws` enables typed error handling
- ✅ **Documentation**: Each method includes HTTP verb, path, and OpenAPI reference
- ✅ **Operation namespacing**: Input/Output types scoped to specific operations

### 2. Client Struct: The Implementation

The `Client` struct implements `APIProtocol`:

```swift
internal struct Client: APIProtocol {
    /// The underlying HTTP client
    private let client: UniversalClient

    /// Creates a new client
    /// - Parameters:
    ///   - serverURL: The server URL (from Servers enum or custom)
    ///   - configuration: Client configuration options
    ///   - transport: HTTP transport layer (URLSession, custom, etc.)
    ///   - middlewares: Request/response middleware chain
    internal init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
}
```

**Architecture benefits:**

- **Dependency injection**: Transport and middlewares are injectable for testing
- **Configuration flexibility**: Optional configuration with sensible defaults
- **Middleware support**: Enables authentication, logging, retry logic, etc.
- **Protocol abstraction**: Implementation hidden behind `APIProtocol`

### 3. Operation Implementation Pattern

Each operation follows a consistent pattern. Here's `queryRecords`:

```swift
internal func queryRecords(_ input: Operations.queryRecords.Input) async throws
    -> Operations.queryRecords.Output
{
    try await client.send(
        input: input,
        forOperation: Operations.queryRecords.id,
        serializer: { input in
            // Build HTTP request from typed input
            let path = try converter.renderedPath(
                template: "/database/{}/{}/{}/{}/records/query",
                parameters: [
                    input.path.version,
                    input.path.container,
                    input.path.environment,
                    input.path.database
                ]
            )

            var request: HTTPTypes.HTTPRequest = .init(
                soar_path: path,
                method: .post
            )

            // Set headers
            converter.setAcceptHeader(
                in: &request.headerFields,
                contentTypes: input.headers.accept
            )

            // Serialize body
            let body: OpenAPIRuntime.HTTPBody?
            switch input.body {
            case let .json(value):
                body = try converter.setRequiredRequestBodyAsJSON(
                    value,
                    headerFields: &request.headerFields,
                    contentType: "application/json; charset=utf-8"
                )
            }

            return (request, body)
        },
        deserializer: { response, responseBody in
            // Deserialize HTTP response to typed output
            switch response.status.code {
            case 200:
                let body = try await converter.getResponseBodyAsJSON(
                    Components.Schemas.QueryResponse.self,
                    from: responseBody,
                    transforming: { .json($0) }
                )
                return .ok(.init(body: body))

            case 400:
                let body = try await converter.getResponseBodyAsJSON(
                    Components.Schemas.ErrorResponse.self,
                    from: responseBody,
                    transforming: { .json($0) }
                )
                return .badRequest(.init(body: body))

            // ... cases for 401, 403, 404, 409, 412, 413, etc.

            default:
                return .undocumented(
                    statusCode: response.status.code,
                    .init(headerFields: response.headerFields, body: responseBody)
                )
            }
        }
    )
}
```

**Pattern breakdown:**

1. **Serializer closure**: Converts typed `Input` → raw HTTP request
2. **Path rendering**: Type-safe path parameter substitution
3. **Header management**: Content-Type and Accept headers automatically set
4. **Body serialization**: Codable JSON encoding with proper content types
5. **Deserializer closure**: Converts raw HTTP response → typed `Output`
6. **Status code switching**: Each HTTP status becomes a distinct enum case
7. **Type-safe deserialization**: JSON decoded to specific schema types
8. **Undocumented fallback**: Handles unexpected status codes gracefully

### 4. Convenience Extensions

For better ergonomics, generated code includes convenience overloads:

```swift
extension APIProtocol {
    /// Query Records
    ///
    /// Convenience overload with parameters instead of Input struct
    internal func queryRecords(
        path: Operations.queryRecords.Input.Path,
        headers: Operations.queryRecords.Input.Headers = .init(),
        body: Operations.queryRecords.Input.Body
    ) async throws -> Operations.queryRecords.Output {
        try await queryRecords(Operations.queryRecords.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
}
```

**Usage comparison:**

```swift
// Without convenience extension
let response = try await client.queryRecords(.init(
    path: .init(version: "1", container: "iCloud.com.example",
                environment: .production, database: ._public),
    headers: .init(accept: [.json]),
    body: .json(.init(query: .init(recordType: "User")))
))

// With convenience extension (cleaner)
let response = try await client.queryRecords(
    path: .init(version: "1", container: "iCloud.com.example",
                environment: .production, database: ._public),
    body: .json(.init(query: .init(recordType: "User")))
)
```

### 5. Servers Enum

Server URLs from the OpenAPI spec are codified as type-safe enums:

```swift
/// Server URLs defined in the OpenAPI document
internal enum Servers {
    /// CloudKit Web Services API
    internal enum Server1 {
        internal static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://api.apple-cloudkit.com",
                variables: []
            )
        }
    }
}
```

**Usage:**

```swift
let serverURL = try Servers.Server1.url()
let client = Client(
    serverURL: serverURL,
    transport: URLSessionTransport()
)
```

This prevents hardcoded URL strings and enables server URL validation.

## Types.swift: Type Definitions

### 1. Components Namespace

All types are organized under the `Components` enum namespace:

```swift
/// Types generated from the components section of the OpenAPI document
internal enum Components {
    /// Types generated from `#/components/schemas`
    internal enum Schemas { /* data models */ }

    /// Types generated from `#/components/parameters`
    internal enum Parameters { /* parameter types */ }

    /// Types generated from `#/components/requestBodies`
    internal enum RequestBodies { /* (empty in CloudKit API) */ }

    /// Types generated from `#/components/responses`
    internal enum Responses { /* reusable response types */ }
}
```

### 2. Schema Types: Data Models

Schemas become structs with Codable, Hashable, and Sendable conformance:

```swift
/// - Remark: Generated from `#/components/schemas/ZoneID`
internal struct ZoneID: Codable, Hashable, Sendable {
    /// - Remark: Generated from `#/components/schemas/ZoneID/zoneName`
    internal var zoneName: Swift.String?

    /// - Remark: Generated from `#/components/schemas/ZoneID/ownerName`
    internal var ownerName: Swift.String?

    /// Creates a new `ZoneID`
    ///
    /// - Parameters:
    ///   - zoneName: Zone name
    ///   - ownerName: Owner name
    internal init(
        zoneName: Swift.String? = nil,
        ownerName: Swift.String? = nil
    ) {
        self.zoneName = zoneName
        self.ownerName = ownerName
    }

    internal enum CodingKeys: String, CodingKey {
        case zoneName
        case ownerName
    }
}
```

**Generated features:**

- ✅ Optional properties with nil defaults
- ✅ Explicit CodingKeys for JSON mapping
- ✅ Memberwise initializer with defaults
- ✅ Full protocol conformance (Codable, Hashable, Sendable)
- ✅ OpenAPI reference in documentation

### 3. Enum Types: Type-Safe Constants

String enums in OpenAPI become Swift enums with raw values:

```swift
/// - Remark: Generated from `#/components/schemas/Filter/comparator`
internal enum comparatorPayload: String, Codable, Hashable, Sendable, CaseIterable {
    case EQUALS = "EQUALS"
    case NOT_EQUALS = "NOT_EQUALS"
    case LESS_THAN = "LESS_THAN"
    case LESS_THAN_OR_EQUALS = "LESS_THAN_OR_EQUALS"
    case GREATER_THAN = "GREATER_THAN"
    case GREATER_THAN_OR_EQUALS = "GREATER_THAN_OR_EQUALS"
    case NEAR = "NEAR"
    case CONTAINS_ALL_TOKENS = "CONTAINS_ALL_TOKENS"
    case IN = "IN"
    case NOT_IN = "NOT_IN"
    case CONTAINS_ANY_TOKENS = "CONTAINS_ANY_TOKENS"
    case LIST_CONTAINS = "LIST_CONTAINS"
    case NOT_LIST_CONTAINS = "NOT_LIST_CONTAINS"
    case BEGINS_WITH = "BEGINS_WITH"
    case NOT_BEGINS_WITH = "NOT_BEGINS_WITH"
    case LIST_MEMBER_BEGINS_WITH = "LIST_MEMBER_BEGINS_WITH"
    case NOT_LIST_MEMBER_BEGINS_WITH = "NOT_LIST_MEMBER_BEGINS_WITH"
}
```

**Type safety benefits:**

- ✅ Autocomplete for all valid values
- ✅ Compile-time checking (can't use invalid comparator)
- ✅ CaseIterable for enumeration
- ✅ Codable for automatic JSON encoding/decoding

**Before (string literals):**
```swift
// Easy to typo, no autocomplete
let filter = Filter(comparator: "GRETER_THAN", ...) // Typo!
```

**After (type-safe enum):**
```swift
// Autocomplete, compile-time safety
let filter = Filter(comparator: .GREATER_THAN, ...)
```

### 4. Error Response Types

Error responses are fully typed with nested enums for error codes:

```swift
/// - Remark: Generated from `#/components/schemas/ErrorResponse`
internal struct ErrorResponse: Codable, Hashable, Sendable {
    internal var uuid: Swift.String?

    /// Server error code enum
    internal enum serverErrorCodePayload: String, Codable, Hashable, Sendable {
        case ACCESS_DENIED = "ACCESS_DENIED"
        case ATOMIC_ERROR = "ATOMIC_ERROR"
        case AUTHENTICATION_FAILED = "AUTHENTICATION_FAILED"
        case AUTHENTICATION_REQUIRED = "AUTHENTICATION_REQUIRED"
        case BAD_REQUEST = "BAD_REQUEST"
        case CONFLICT = "CONFLICT"
        case EXISTS = "EXISTS"
        case INTERNAL_ERROR = "INTERNAL_ERROR"
        case NOT_FOUND = "NOT_FOUND"
        case QUOTA_EXCEEDED = "QUOTA_EXCEEDED"
        case THROTTLED = "THROTTLED"
        case TRY_AGAIN_LATER = "TRY_AGAIN_LATER"
        case VALIDATING_REFERENCE_ERROR = "VALIDATING_REFERENCE_ERROR"
        case ZONE_NOT_FOUND = "ZONE_NOT_FOUND"
    }

    internal var serverErrorCode: serverErrorCodePayload?
    internal var reason: Swift.String?
    internal var redirectURL: Swift.String?
}
```

**Error handling example:**

```swift
do {
    let response = try await client.queryRecords(...)
} catch {
    // Type-safe error handling
    if case let .badRequest(badRequest) = response,
       case let .json(errorResponse) = try badRequest.body.json,
       errorResponse.serverErrorCode == .AUTHENTICATION_FAILED {
        print("Authentication failed: \(errorResponse.reason ?? "Unknown")")
    }
}
```

### 5. Parameters: Path and Query Parameters

Parameters are defined as typealiases or enums:

```swift
internal enum Parameters {
    /// Protocol version
    /// - Remark: Generated from `#/components/parameters/version`
    internal typealias version = Swift.String

    /// Container ID (begins with "iCloud.")
    /// - Remark: Generated from `#/components/parameters/container`
    internal typealias container = Swift.String

    /// Container environment
    /// - Remark: Generated from `#/components/parameters/environment`
    internal enum environment: String, Codable, Hashable, Sendable, CaseIterable {
        case development = "development"
        case production = "production"
    }

    /// Database scope
    /// - Remark: Generated from `#/components/parameters/database`
    internal enum database: String, Codable, Hashable, Sendable, CaseIterable {
        case _public = "public"      // Leading underscore (Swift keyword)
        case _private = "private"    // Leading underscore (Swift keyword)
        case shared = "shared"
    }
}
```

**Keyword escaping:**

Notice `_public` and `_private` have leading underscores because `public` and `private` are Swift keywords. The generator handles this automatically.

### 6. Operations Namespace

Each API operation gets a dedicated namespace with Input and Output types:

```swift
internal enum Operations {
    internal enum queryRecords {
        internal static let id: Swift.String = "queryRecords"

        // INPUT TYPES
        internal struct Input: Sendable, Hashable {
            /// Path parameters
            internal struct Path: Sendable, Hashable {
                internal var version: Components.Parameters.version
                internal var container: Components.Parameters.container
                internal var environment: Components.Parameters.environment
                internal var database: Components.Parameters.database
            }

            /// Headers
            internal struct Headers: Sendable, Hashable {
                internal var accept: [OpenAPIRuntime.AcceptHeaderContentType<
                    Operations.queryRecords.AcceptableContentType
                >]

                internal init(
                    accept: [OpenAPIRuntime.AcceptHeaderContentType<
                        Operations.queryRecords.AcceptableContentType
                    >] = .defaultValues()
                ) {
                    self.accept = accept
                }
            }

            /// Request body
            internal enum Body: Sendable, Hashable {
                case json(Components.Schemas.QueryRequest)
            }

            internal var path: Path
            internal var headers: Headers
            internal var body: Body
        }

        // OUTPUT TYPES
        internal enum Output: Sendable, Hashable {
            /// 200 OK response
            internal struct Ok: Sendable, Hashable {
                internal enum Body: Sendable, Hashable {
                    case json(Components.Schemas.QueryResponse)

                    internal var json: Components.Schemas.QueryResponse {
                        get throws {
                            switch self {
                            case let .json(body): return body
                            }
                        }
                    }
                }
                internal var body: Body
            }

            /// Response cases for each HTTP status
            case ok(Ok)
            case badRequest(Components.Responses.BadRequest)
            case unauthorized(Components.Responses.Unauthorized)
            case forbidden(Components.Responses.Forbidden)
            case notFound(Components.Responses.NotFound)
            case conflict(Components.Responses.Conflict)
            case preconditionFailed(Components.Responses.PreconditionFailed)
            case requestEntityTooLarge(Components.Responses.RequestEntityTooLarge)
            case undocumented(statusCode: Int, UndocumentedPayload)
        }
    }
}
```

**Type hierarchy:**

```
Operations
└── queryRecords
    ├── id (operation identifier)
    ├── Input
    │   ├── Path (path parameters)
    │   ├── Headers (HTTP headers)
    │   └── Body (request body)
    └── Output (enum of response cases)
        ├── ok(Ok)
        ├── badRequest(...)
        ├── unauthorized(...)
        └── undocumented(...)
```

This deep nesting prevents naming conflicts and keeps types organized by operation.

### 7. Response Body Access Pattern

Generated response types use throwing computed properties for safe unwrapping:

```swift
internal enum Body: Sendable, Hashable {
    case json(Components.Schemas.QueryResponse)

    /// Safe accessor throwing if wrong case
    internal var json: Components.Schemas.QueryResponse {
        get throws {
            switch self {
            case let .json(body):
                return body
            }
        }
    }
}
```

**Usage:**

```swift
let response = try await client.queryRecords(...)

switch response {
case let .ok(okResponse):
    // Type-safe access to response body
    let queryResponse = try okResponse.body.json
    for record in queryResponse.records ?? [] {
        print(record)
    }

case let .badRequest(errorResponse):
    let error = try errorResponse.body.json
    print("Error: \(error.serverErrorCode)")

default:
    print("Unexpected response")
}
```

## Type Safety Comparison

### Before: Manual HTTP + JSON

```swift
// Manual HTTP client - error-prone, no compile-time safety

let urlString = "https://api.apple-cloudkit.com/database/1/" +
                "\(container)/production/public/records/query"
var request = URLRequest(url: URL(string: urlString)!)
request.httpMethod = "POST"
request.setValue("application/json", forHTTPHeaderField: "Content-Type")

// Easy to make mistakes - typos, wrong nesting, missing fields
let json: [String: Any] = [
    "query": [
        "recordType": "User",
        "filterBy": [  // Typo: should be array of filter objects
            "fieldName": "age",
            "comparator": "GRETER_THAN",  // Typo: GREATER_THAN
            "fieldValue": ["value": 18]
        ]
    ]
]

let data = try JSONSerialization.data(withJSONObject: json)
request.httpBody = data

let (responseData, _) = try await URLSession.shared.data(for: request)

// Manual parsing - type casting everywhere
let responseJSON = try JSONSerialization.jsonObject(with: responseData) as! [String: Any]
let records = responseJSON["records"] as? [[String: Any]] ?? []
```

**Problems:**

- ❌ No compile-time verification
- ❌ Easy to typo field names
- ❌ Wrong types accepted (e.g., single dict instead of array)
- ❌ Typos in enum values ("GRETER_THAN")
- ❌ Manual JSON serialization/deserialization
- ❌ Type casting hell
- ❌ No autocomplete support

### After: Generated Type-Safe Client

```swift
// Type-safe generated client - compile-time safety, autocomplete

let response = try await client.queryRecords(
    path: .init(
        version: "1",
        container: container,
        environment: .production,  // Enum - can't typo
        database: ._public          // Enum - can't typo
    ),
    body: .json(.init(
        query: .init(
            recordType: "User",
            filterBy: [  // Correctly typed as array
                .init(
                    fieldName: "age",
                    comparator: .GREATER_THAN,  // Enum - autocomplete, can't typo
                    fieldValue: .init(value: .int64(18))  // Type-safe value
                )
            ]
        )
    ))
)

// Type-safe response handling
switch response {
case let .ok(okResponse):
    let queryResponse = try okResponse.body.json
    // queryResponse is strongly typed as Components.Schemas.QueryResponse
    for record in queryResponse.records ?? [] {
        // record is strongly typed
        print(record.recordName)
    }

case let .badRequest(error):
    let errorResponse = try error.body.json
    // errorResponse is strongly typed as Components.Schemas.ErrorResponse
    if errorResponse.serverErrorCode == .AUTHENTICATION_FAILED {
        print("Auth failed: \(errorResponse.reason ?? "")")
    }

default:
    print("Unexpected response")
}
```

**Benefits:**

- ✅ Compile-time verification of request structure
- ✅ Autocomplete for all fields and enums
- ✅ Impossible to typo enum values
- ✅ Correct types enforced by compiler
- ✅ Automatic JSON serialization/deserialization
- ✅ Strongly typed responses
- ✅ Exhaustive error handling

## Swift Language Features

### 1. Conditional Compilation for Platform Support

Generated code handles platform differences:

```swift
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
```

**Why:**

- Linux doesn't have full Sendable conformance for Foundation types in older versions
- `@preconcurrency` suppresses concurrency warnings on Linux
- Enables cross-platform compatibility (macOS, iOS, Linux)

### 2. Sendable Conformance for Concurrency Safety

All generated types conform to Sendable:

```swift
internal protocol APIProtocol: Sendable { ... }
internal struct Client: APIProtocol { ... }
internal struct Input: Sendable, Hashable { ... }
internal enum Output: Sendable, Hashable { ... }
```

**Benefits:**

- ✅ Safe to pass across actor boundaries
- ✅ Safe to use in async/await contexts
- ✅ Compile-time data race prevention (Swift 6)
- ✅ No runtime concurrency overhead

### 3. Async/Await Throughout

All API methods use modern Swift concurrency:

```swift
func queryRecords(_ input: Input) async throws -> Output
```

**Benefits:**

- ✅ Structured concurrency support
- ✅ Automatic task cancellation propagation
- ✅ Better error handling than completion closures
- ✅ TaskGroup support for parallel operations

### 4. Throwing Computed Properties

Safe access to enum associated values:

```swift
internal var json: Components.Schemas.QueryResponse {
    get throws {
        switch self {
        case let .json(body):
            return body
        }
    }
}
```

**Usage:**

```swift
// Safe unwrapping with throws
let queryResponse = try okResponse.body.json

// Compiler enforces error handling
```

## Integration with MistKit Wrapper

### 1. MistKitClient Wraps Generated Client

```swift
@available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
internal struct MistKitClient {
    /// The underlying OpenAPI client
    internal let client: Client  // Generated Client struct

    internal init(
        configuration: MistKitConfiguration,
        transport: any ClientTransport
    ) throws {
        let tokenManager = try configuration.createTokenManager()

        self.client = Client(
            serverURL: configuration.serverURL,
            transport: transport,
            middlewares: [
                AuthenticationMiddleware(tokenManager: tokenManager),
                LoggingMiddleware()
            ]
        )
    }
}
```

**Wrapper responsibilities:**

- ✅ Configuration management
- ✅ Token manager creation
- ✅ Middleware injection
- ✅ Server URL construction
- ✅ Higher-level convenience APIs

### 2. AuthenticationMiddleware Integration

The generated client's middleware support enables authentication:

```swift
internal struct AuthenticationMiddleware: ClientMiddleware {
    private let tokenManager: any TokenManager

    func intercept(
        _ request: HTTPRequest,
        body: HTTPBody?,
        baseURL: URL,
        operationID: String,
        next: (HTTPRequest, HTTPBody?, URL) async throws -> (HTTPResponse, HTTPBody?)
    ) async throws -> (HTTPResponse, HTTPBody?) {
        // Add CloudKit authentication headers/query parameters
        var authenticatedRequest = request

        let credentials = try await tokenManager.credentials()
        // Add authentication based on credentials type
        // ...

        return try await next(authenticatedRequest, body, baseURL)
    }
}
```

**Middleware chain flow:**

```
Request
  ↓
AuthenticationMiddleware (adds auth)
  ↓
LoggingMiddleware (logs request)
  ↓
Transport (URLSession)
  ↓
HTTP Network
  ↓
Response
```

### 3. Custom Type Override: CustomFieldValue

The configuration specifies a type override:

```yaml
typeOverrides:
  schemas:
    FieldValue: CustomFieldValue
```

Generated code references the custom type:

```swift
// In generated Types.swift
internal var fieldValue: CustomFieldValue?  // Not Components.Schemas.FieldValue
```

**MistKit implementation** (`CustomFieldValue.swift`):

```swift
internal struct CustomFieldValue: Codable, Hashable, Sendable {
    // Custom implementation for CloudKit-specific field value handling
    internal enum CustomFieldValuePayload {
        case string(String)
        case int64(Int64)
        case double(Double)
        case timestamp(Date)
        case bytes(Data)
        case reference(RecordReference)
        case asset(Asset)
        case location(Location)
        case stringList([String])
        case int64List([Int64])
        case doubleList([Double])
        case timestampList([Date])
        case referenceList([RecordReference])
        case assetList([Asset])
    }

    internal var payload: CustomFieldValuePayload
    // Custom Codable implementation...
}
```

This allows MistKit to provide CloudKit-specific field value semantics while using the generated code.

## Architecture Patterns

### 1. Namespace Organization

```
Client.swift
├── APIProtocol (protocol)
├── Client (struct)
├── APIProtocol extension (convenience methods)
└── Servers (enum)

Types.swift
├── Components (namespace enum)
│   ├── Schemas (data models)
│   ├── Parameters (parameter types)
│   ├── RequestBodies (empty)
│   └── Responses (response types)
└── Operations (namespace enum)
    ├── queryRecords
    │   ├── id
    │   ├── Input
    │   └── Output
    ├── modifyRecords
    │   ├── id
    │   ├── Input
    │   └── Output
    └── ... (13 more operations)
```

**Benefits:**

- ✅ No naming conflicts between operations
- ✅ Clear ownership of types
- ✅ Logical grouping
- ✅ Easy navigation

### 2. Enum-Based Response Handling

```swift
internal enum Output: Sendable, Hashable {
    case ok(Ok)
    case badRequest(BadRequest)
    case unauthorized(Unauthorized)
    // ... more cases
    case undocumented(statusCode: Int, UndocumentedPayload)
}
```

**Pattern benefits:**

- ✅ Exhaustive switch coverage required by compiler
- ✅ Each status code is a distinct type
- ✅ Forces explicit error handling
- ✅ Fallback for unexpected responses (undocumented)

**Usage:**

```swift
switch response {
case .ok(let okResponse):
    // Handle success

case .badRequest(let error):
    // Handle 400

case .unauthorized(let error):
    // Handle 401

case .undocumented(let statusCode, _):
    // Handle unexpected status
    print("Unexpected status: \(statusCode)")
}
```

### 3. Protocol-Oriented Design

```swift
// Protocol defines contract
internal protocol APIProtocol: Sendable {
    func queryRecords(...) async throws -> Output
}

// Struct implements protocol
internal struct Client: APIProtocol {
    // Implementation
}

// Middleware uses protocol
internal struct AuthenticationMiddleware: ClientMiddleware {
    // Works with any APIProtocol implementation
}
```

**Benefits:**

- ✅ Easy to mock for testing
- ✅ Flexible implementation swapping
- ✅ Clear separation of interface and implementation

## Performance Considerations

### 1. Struct Value Semantics

All types are structs (except protocols and enums):

```swift
internal struct Client { ... }
internal struct Input { ... }
internal struct ZoneID { ... }
```

**Benefits:**

- ✅ No heap allocation for most types
- ✅ Copy-on-write semantics
- ✅ Better cache locality
- ✅ Automatic memory management

### 2. Lazy JSON Parsing

Response bodies use streaming:

```swift
let body = try await converter.getResponseBodyAsJSON(
    Components.Schemas.QueryResponse.self,
    from: responseBody  // HTTPBody (streaming)
)
```

**Benefits:**

- ✅ Doesn't buffer entire response in memory
- ✅ Efficient for large responses
- ✅ Progressive parsing

### 3. Minimal Allocations

Generated code avoids unnecessary allocations:

```swift
// Reuses converter instance
private var converter: Converter {
    client.converter
}

// Uses inout for mutations
converter.setAcceptHeader(
    in: &request.headerFields,  // inout - no copy
    contentTypes: input.headers.accept
)
```

## Testing Considerations

### 1. Protocol Abstraction Enables Mocking

```swift
// Test with mock implementation
struct MockClient: APIProtocol {
    func queryRecords(_ input: Input) async throws -> Output {
        // Return canned response
        return .ok(.init(body: .json(mockQueryResponse)))
    }
}

// Use in tests
let mockClient = MockClient()
let wrapper = MistKitClient(client: mockClient)
```

### 2. Transport Injection

```swift
// Custom transport for testing
struct MockTransport: ClientTransport {
    func send(
        _ request: HTTPRequest,
        body: HTTPBody?,
        baseURL: URL,
        operationID: String
    ) async throws -> (HTTPResponse, HTTPBody?) {
        // Return mock response
    }
}

let client = Client(
    serverURL: testServerURL,
    transport: MockTransport()
)
```

### 3. Middleware Testing

```swift
// Test middleware in isolation
let middleware = AuthenticationMiddleware(tokenManager: mockTokenManager)

let (response, body) = try await middleware.intercept(
    request,
    body: nil,
    baseURL: baseURL,
    operationID: "queryRecords",
    next: { req, body, url in
        // Verify authentication was added
        XCTAssertNotNil(req.headerFields[.authorization])
        return (mockResponse, mockBody)
    }
)
```

## See Also

- <doc:OpenAPICodeGeneration>
- [OpenAPI Runtime Documentation](https://github.com/apple/swift-openapi-runtime)
- [HTTPTypes Documentation](https://github.com/apple/swift-http-types)
- ``MistKitClient``
- ``AuthenticationMiddleware``
- ``CustomFieldValue``
